<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[MyBatis]学习笔记</title>
      <link href="/2019/09/16/Mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/16/Mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础方式的增删改查CRUD"><a href="#一、基础方式的增删改查CRUD" class="headerlink" title="一、基础方式的增删改查CRUD:"></a>一、基础方式的增删改查CRUD:</h1><p>mybatis约定：<br>输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个</p><a id="more"></a><p><strong>输入参数 ：</strong></p><p>是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx}</p><p>如果是对象类型，则必须是对象的属性 #{属性名}</p><p><strong>取值方式：</strong></p><p>a.#{任意值} 或 ${value} ，其中的标识符只能是value</p><p>b.#{}自动给String类型加上’’  （自动类型转换）</p><p>  ${} 原样输出，但是适合于 动态排序（动态字段）</p><p>动态排序：<br><code>select stuno,stuname,stuage  from student  order by ${value} asc</code></p><p><strong>输出参数 ：</strong></p><p><strong>a.resultType</strong></p><p>1.简单类型（8个基本+String）</p><p>2.输出参数为实体对象类型</p><p>3.输出参数为实体对象类型的集合 ：虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=”Student”）</p><p>4.输出参数类型为HashMap</p><p>如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个，<br>        再resultType都写成org.lanqiao.entity.Student<br>        即 resultType=”org.lanqiao.entity.Student”</p><p><strong>例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryAllstudentByName1&quot; parameterType=&quot;org.com.entity.Student&quot; resultType=&quot;org.com.entity.Student&quot;  &gt;</span><br><span class="line">select * from student where name=#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><strong>b.resultMap:</strong> 实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;student&quot; id=&quot;queryStudentByIdMap&quot;&gt;</span><br><span class="line">&lt;!-- 指定类中的属性 和 表中的字段 对应关系 --&gt;</span><br><span class="line">&lt;id property=&quot;stuNo&quot;  column=&quot;id&quot; /&gt;</span><br><span class="line">&lt;result property=&quot;stuName&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><h4 id="a如果使用的-事务方式为-jdbc-则需要-手工commit提交，即session-commit"><a href="#a如果使用的-事务方式为-jdbc-则需要-手工commit提交，即session-commit" class="headerlink" title="a如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit();"></a>a如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit();</h4><h4 id="b所有的标签-select-update等-，都必须有sql语句，但是sql参数值可选"><a href="#b所有的标签-select-update等-，都必须有sql语句，但是sql参数值可选" class="headerlink" title="b所有的标签 select update等 ，都必须有sql语句，但是sql参数值可选"></a>b所有的标签 select update等 ，都必须有sql语句，但是sql参数值可选</h4><p> select* from student  where stuno = #{xx}<br>sql有参数：session.insert(statement, 参数值 );</p><p>sql没参数：session.insert(statement);</p><h1 id="二、mapper动态代理方式的crud-（MyBatis接口开发）"><a href="#二、mapper动态代理方式的crud-（MyBatis接口开发）" class="headerlink" title="二、mapper动态代理方式的crud （MyBatis接口开发）:"></a>二、mapper动态代理方式的crud （MyBatis接口开发）:</h1><p><strong>原则：约定优于配置</strong></p><p><strong>硬编码方式</strong><br>    abc.java<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = new Configuration();</span><br><span class="line">con.setName(&quot;myProject&quot;) ;</span><br><span class="line">   ```  </span><br><span class="line"></span><br><span class="line">**配置方式：**</span><br><span class="line">abc.xml   </span><br><span class="line">```&lt;name&gt;myProject&lt;/name&gt;</span><br></pre></td></tr></table></figure></p><p>约定：默认值就是myProject</p><p><strong>具体实现的步骤：</strong></p><h3 id="1-基础环境：mybatis-jar-ojdbc-jar、conf-xml、mapper-xml"><a href="#1-基础环境：mybatis-jar-ojdbc-jar、conf-xml、mapper-xml" class="headerlink" title="1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml"></a>1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml</h3><h3 id="2-（不同之处）"><a href="#2-（不同之处）" class="headerlink" title="2.（不同之处）"></a>2.（不同之处）</h3><pre><code>约定的目标： 省略掉statement,即根据约定 直接可以定位出SQL语句</code></pre><h4 id="a-接口，接口中的方法必须遵循以下约定："><a href="#a-接口，接口中的方法必须遵循以下约定：" class="headerlink" title="a.接口，接口中的方法必须遵循以下约定："></a>a.接口，接口中的方法必须遵循以下约定：</h4><h5 id="1-方法名和mapper-xml文件中标签的id值相同"><a href="#1-方法名和mapper-xml文件中标签的id值相同" class="headerlink" title="1.方法名和mapper.xml文件中标签的id值相同"></a>1.方法名和mapper.xml文件中标签的id值相同</h5><h5 id="2-方法的-输入参数-和mapper-xml文件中标签的-parameterType类型一致-如果mapper-xml的标签中没有-parameterType，则说明方法没有输入参数"><a href="#2-方法的-输入参数-和mapper-xml文件中标签的-parameterType类型一致-如果mapper-xml的标签中没有-parameterType，则说明方法没有输入参数" class="headerlink" title="2.方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数)"></a>2.方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数)</h5><h5 id="3-方法的返回值-和mapper-xml文件中标签的-resultType类型一致-（无论查询结果是一个-还是多个（student、List），在mapper-xml标签中的resultType中只写-一个（Student）；如果没有resultType，则说明方法的返回值为void）"><a href="#3-方法的返回值-和mapper-xml文件中标签的-resultType类型一致-（无论查询结果是一个-还是多个（student、List），在mapper-xml标签中的resultType中只写-一个（Student）；如果没有resultType，则说明方法的返回值为void）" class="headerlink" title="3.方法的返回值  和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void）"></a>3.方法的返回值  和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List<student>），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void）</student></h5><p>除了以上约定，要实现 接口中的方法  和  Mapper.xml中SQL标签一一对应，还需要以下1点：<br>    namespace的值 ，就是  接口的全类名（ 接口 - mapper.xml 一一对应）</p><p><strong>匹配的过程：（约定的过程）</strong><br>1.根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名）<br>2.根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值）</p><p>以上2点可以保证： 当我们调用接口中的方法时，<br>程序能自动定位到 某一个Mapper.xml文件中的sqL标签</p><p><strong>习惯：</strong>SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径）</p><p>以上，可以通过接口的方法-&gt;SQL语句</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper studentMapper = session.getMapper(StudentMapper.class) ;</span><br><span class="line">studentMapper.方法();</span><br></pre></td></tr></table></figure><p>通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。</p><h1 id="关联查询："><a href="#关联查询：" class="headerlink" title="关联查询："></a>关联查询：</h1><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一:"></a>一对一:</h3><p><strong>a.业务扩展类</strong><br>        核心：用resultType指定类的属性 包含 多表查询的所有字段</p><p><strong>b.resultMap</strong><br>    1.通过 属性成员 将2个类建立起联系</p><pre><code>2.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;student&quot; id=&quot;student_card_map&quot;&gt;</span><br><span class="line">&lt;!-- 学生的信息 --&gt;</span><br><span class="line">&lt;id  property=&quot;stuNo&quot; column=&quot;stuNo&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;stuName&quot; column=&quot;stuName&quot; /&gt;</span><br><span class="line">&lt;result property=&quot;stuAge&quot; column=&quot;stuAge&quot; /&gt;</span><br><span class="line">&lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的--&gt;</span><br><span class="line">&lt;association property=&quot;card&quot; javaType=&quot;StudentCard&quot; &gt;</span><br><span class="line">&lt;id property=&quot;cardId&quot; column=&quot;cardId&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;cardInfo&quot; column=&quot;cardInfo&quot;/&gt;</span><br><span class="line">&lt;/association&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>一对一：association<br>一对多：collection</p><h3 id="一对多："><a href="#一对多：" class="headerlink" title="一对多："></a>一对多：</h3><p>表：student studentclass  (关联：classid)<br>类：student studentClass  (关联：List<student> students )</student></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select  c.*,s.* from student s</span><br><span class="line">inner join studentclass c </span><br><span class="line">on c.classid = s.classid</span><br><span class="line">where c.classid = 1;</span><br></pre></td></tr></table></figure><h3 id="多对一-多对多"><a href="#多对一-多对多" class="headerlink" title="多对一 多对多"></a>多对一 多对多</h3><p>MyBatis:多对一，多对多的本质就是  一对多的变化</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埼玉老师来啦</title>
      <link href="/2019/08/17/%E5%9F%BC%E7%8E%89%E8%80%81%E5%B8%88%E6%9D%A5%E5%95%A6/"/>
      <url>/2019/08/17/%E5%9F%BC%E7%8E%89%E8%80%81%E5%B8%88%E6%9D%A5%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="埼玉老师天下无敌"><a href="#埼玉老师天下无敌" class="headerlink" title="埼玉老师天下无敌"></a>埼玉老师天下无敌</h1><a id="more"></a><p><img src="1.jpg" alt="埼玉老师"></p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一拳超人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建遇到的小问题</title>
      <link href="/2019/08/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/08/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="小问题总结"><a href="#小问题总结" class="headerlink" title="小问题总结"></a>小问题总结</h2><h3 id="问题一：npm安装速度过慢"><a href="#问题一：npm安装速度过慢" class="headerlink" title="问题一：npm安装速度过慢"></a>问题一：npm安装速度过慢</h3><h3 id="解决方案：使用淘宝镜像站，命令如下："><a href="#解决方案：使用淘宝镜像站，命令如下：" class="headerlink" title="解决方案：使用淘宝镜像站，命令如下："></a>解决方案：使用淘宝镜像站，命令如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>过程可能会很慢，要是还不行就只能科学上网了 ，安装完之后就用cnpm代替npm命令就行啦</p><a id="more"></a><h3 id="问题二：hexo-d-命令无效"><a href="#问题二：hexo-d-命令无效" class="headerlink" title="问题二：hexo d 命令无效"></a>问题二：hexo d 命令无效</h3><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>注意repo：冒号后面要加上空格，类似其他的配置也要记得加空格！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxx</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
