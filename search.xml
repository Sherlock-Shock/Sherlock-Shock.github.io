<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[SpringMVC]之数据处理</title>
      <link href="/2019/09/18/SpringMVC-%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2019/09/18/SpringMVC-%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-错误消息："><a href="#1-错误消息：" class="headerlink" title="1.错误消息："></a>1.错误消息：</h1><p>public String testDateTimeFormat(Student student, <strong>BindingResult result</strong> ,Map&lt;String,Object&gt; map) {}</p><p>需要验证的数据是 Student中的birthday, SPringMVC要求,如果校验失败 ,则将错误信息自动放入该对象之后紧挨着的BindingResult中。<br>即Student student, BindingResult result之间 不能有其他参数。</p><p>如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。</p><a id="more"></a><h1 id="2-数据校验"><a href="#2-数据校验" class="headerlink" title="2. 数据校验"></a>2. 数据校验</h1><pre><code>JSR303  Hibernate Validator </code></pre><p><strong>使用Hibernate Validator步骤：</strong></p><h2 id="jar（注意各个jar之间可能存在版本不兼容）"><a href="#jar（注意各个jar之间可能存在版本不兼容）" class="headerlink" title="jar（注意各个jar之间可能存在版本不兼容）"></a>jar（注意各个jar之间可能存在版本不兼容）</h2><p>hibernate-validator-5.0.0.CR2.jar     classmate-0.8.0.jar </p><p>jboss-logging-3.1.1.GA.jar</p><p>validation-api-1.1.0.CR1.jar     </p><p>hibernate-validator-annotation-processor-5.0.0.CR2.jar</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory</p><p>LocalValidatorFactoryBean是ValidatorFactory的一个实现类。<br>&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。</p><h2 id="直接使用注解"><a href="#直接使用注解" class="headerlink" title="直接使用注解"></a>直接使用注解</h2><pre><code>public class Student {    @Past//当前时间以前    private Date birthday ;}</code></pre><p>在校验的Controller中 ，给校验的对象前增加 @Valid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123;</span><br><span class="line">                &#123;...&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Ajax请求SpringMVC，并且返回JSON格式的数据"><a href="#3-Ajax请求SpringMVC，并且返回JSON格式的数据" class="headerlink" title="3.Ajax请求SpringMVC，并且返回JSON格式的数据"></a>3.Ajax请求SpringMVC，并且返回JSON格式的数据</h1><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>jackson-annotations-2.8.9.jar</p><p>jackson-core-2.8.9.jar</p><p>jackson-databind-2.8.9.jar</p><h2 id="配置controller"><a href="#配置controller" class="headerlink" title="配置controller"></a>配置controller</h2><p>@ResponseBod修饰的方法，会将该方法的返回值 以一个json数组的形式返回给前台</p><p>@ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;testJson&quot;)</span><br><span class="line">public List&lt;Student&gt; testJson() &#123;</span><br><span class="line">//Controller-Service-dao</span><br><span class="line">//StudentService studentService = new StudentServiceImp();</span><br><span class="line">          //List&lt;Student&gt; students =  studentService.qeuryAllStudent();</span><br><span class="line">//模拟调用service的查询操作</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">students.add(stu1) ;</span><br><span class="line">students.add(stu2) ;</span><br><span class="line">students.add(stu3) ;</span><br><span class="line"></span><br><span class="line">return students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前台：服务端将返回值结果 以json数组的形式 传给了result。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#testJson&quot;).click(function()&#123;</span><br><span class="line">//通过ajax请求springmvc</span><br><span class="line">$.post(</span><br><span class="line">&quot;handler/testJson&quot;,//服务器地址</span><br><span class="line">//&#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:23&#125;</span><br><span class="line">function(result)&#123;//服务端处理完毕后的回调函数 List&lt;Student&gt; students， 加上@ResponseBody后， students实质是一个json数组的格式</span><br><span class="line">for(var i=0;i&lt;result.length ;i++)&#123;</span><br><span class="line">alert(result[i].id +&quot;-&quot;+result[i].name +&quot;-&quot;+result[i].age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SpringMVC]之InternalResourceViewResolver</title>
      <link href="/2019/09/17/SpringMVC-%E4%B9%8BInternalResourceViewResolver/"/>
      <url>/2019/09/17/SpringMVC-%E4%B9%8BInternalResourceViewResolver/</url>
      
        <content type="html"><![CDATA[<h1 id="1-直接-lt-mvc-view-controller-…-gt"><a href="#1-直接-lt-mvc-view-controller-…-gt" class="headerlink" title="1.直接&lt;mvc:view-controller …&gt;"></a>1.直接&lt;mvc:view-controller …&gt;</h1><p>一般处理：index.jsp -&gt; Controller(@RequsetMapping(“a”)) -&gt;succes.jsp</p><p>要用SpringMVC实现：index.jsp -&gt; succes.jsp：（不通过Controller(@RequsetMapping(“a”))）</p><a id="more"></a><p>&lt;mvc:view-controller path=”a”   view-name=”success” /&gt;</p><p>以上注解 ，会让所有的请求 转入<a href="mvc:.." target="_blank" rel="noopener">mvc:..</a>中匹配映射地址，而会忽略调@RequsetMapping()；<br>如果想让 @RequsetMapping(“a”)  和<a href="mvc:.." target="_blank" rel="noopener">mvc:..</a>共存，则需要加入一个注解：</p><p><a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a></p><h1 id="2-指定请求方式（重定向）"><a href="#2-指定请求方式（重定向）" class="headerlink" title="2.指定请求方式（重定向）"></a>2.指定请求方式（重定向）</h1><p><strong>指定跳转方式：return “forward:/views/success.jsp”;</strong></p><p>forward:   redirect: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp)</p><h1 id="3-处理静态资源：html-css-js-图片-视频"><a href="#3-处理静态资源：html-css-js-图片-视频" class="headerlink" title="3.处理静态资源：html css js  图片 视频"></a>3.处理静态资源：html css js  图片 视频</h1><p>可以与用户交互、因为时间/地点的不同 而结果不同的内容：动态（百度：天气  ）</p><p>在SpringMVC中，如果直接访问静态资源：404 。原因：之前将所有的请求 通过通配符“、” 拦截，进而交给 SPringMVC的入口DispatcherServlet去处理：找该请求映射对应的 @requestMapping</p><p><a href="http://localhost:8888/SpringMVCProject/img.png" target="_blank" rel="noopener">http://localhost:8888/SpringMVCProject/img.png</a></p><p>@RequsetMapping(“img.png”)</p><p>return sucess</p><p>解决：如果是 需要mvc处理的，则交给@RequsetMapping(“img.png”)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。<br>tomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。<br>tomcat默认的Servlet在哪里？在tomcat配置文件\conf\web.xml中</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;abc&lt;/servlet-name&gt;    &lt;servlet-class&gt;xxx.xxx.xx.ABCServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;abc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/abc&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>解决静态资源方案：如果有springmvc对应的@requestMapping则交给spring处理；如果没有对应@requestMapping,则交给服务器tomcat默认的servlet去处理  ：实现方法，只需要增加2个注解即可 springmvc.xml：<br><a href="mvc:default-servlet-handler" target="_blank" rel="noopener">mvc:default-servlet-handler</a><br><a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a></p><p><strong>总结：要让springmvc访问静态资源，只需要加入以下2个注解：</strong></p><p><a href="mvc:default-servlet-handler" target="_blank" rel="noopener">mvc:default-servlet-handler</a><br><a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a></p><h1 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4.类型转换"></a>4.类型转换</h1><p>a.Spring自带一些 常见的类型转换器：</p><p>public String  testDelete(@PathVariable(“id”) String id) ，即可以接受int类型数据id  也可以接受String类型的id</p><p>b.可以自定义类型转换器</p><p>i.编写 自定义类型转器的类 （实现Converter接口）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyConverter  implements Converter&lt;String,Student&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Student convert(String source) &#123;//source:2-zs-23</span><br><span class="line">//source接受前端传来的String:2-zs-23</span><br><span class="line">String[] studentStrArr = source.split(&quot;-&quot;) ;</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setId(  Integer.parseInt(  studentStrArr[0]) );</span><br><span class="line">student.setName(studentStrArr[1]);</span><br><span class="line">student.setAge(Integer.parseInt(studentStrArr[2] ));</span><br><span class="line">return student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ii.配置：将MyConverter加入到springmvc中</p><!-- 1将 自定义转换器 纳入SpringIOC容器 --><pre><code>&lt;bean  id=&quot;myConverter&quot; class=&quot;org.lanqiao.converter.MyConverter&quot;&gt;&lt;/bean&gt;&lt;!-- 2将myConverter再纳入 SpringMVC提供的转换器Bean --&gt;&lt;bean id=&quot;conversionService&quot;  class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;ref bean=&quot;myConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 3将conversionService注册到annotation-driven中 --&gt;&lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调  --&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>测试转换器：</p><pre><code>@RequestMapping(value=&quot;testConverter&quot;)public String testConverter(@RequestParam(&quot;studentInfo&quot;)  Student student) {// 前端：2-zs-23      System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge());    return &quot;success&quot;;}</code></pre><p>其中@RequestParam(“studentInfo”)是触发转换器的桥梁：<br>@RequestParam(“studentInfo”)接受的数据 是前端传递过来的：2-zs-23  ，但是 需要将该数据 复制给 修饰的目的对象Student；因此SPringMVC可以发现 接收的数据 和目标数据不一致，并且 这两种数据分别是 String、Student,正好符合public Student convert(String source)转换器。</p><h1 id="5-数据格式化"><a href="#5-数据格式化" class="headerlink" title="5.数据格式化"></a>5.数据格式化</h1><pre><code>SimpleDateForamt sdf = new SimpleDateFormat(&quot;yyyy-MM-dd  hh:mm:ss&quot;);</code></pre><p>SPringMVC提供了很多注解，方便我们数据格式化<br>实现步骤：<br>a.配置<br>    <!-- 配置 数据格式化 注解 所依赖的bean --><br>    <bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"><br>    </bean></p><p>b.通过注解使用</p><p><strong>@DateTimeFormat(pattern=”yyyy-MM-dd”)</strong><br><strong>@NumberFormat(parttern=”###,#”)</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MyBatis]学习笔记</title>
      <link href="/2019/09/16/Mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/16/Mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础方式的增删改查CRUD"><a href="#一、基础方式的增删改查CRUD" class="headerlink" title="一、基础方式的增删改查CRUD:"></a>一、基础方式的增删改查CRUD:</h1><p>mybatis约定：<br>输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个</p><a id="more"></a><p><strong>输入参数 ：</strong></p><p>是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx}</p><p>如果是对象类型，则必须是对象的属性 #{属性名}</p><p><strong>取值方式：</strong></p><p>a.#{任意值} 或 ${value} ，其中的标识符只能是value</p><p>b.#{}自动给String类型加上’’  （自动类型转换）</p><p>  ${} 原样输出，但是适合于 动态排序（动态字段）</p><p>动态排序：<br><code>select stuno,stuname,stuage  from student  order by ${value} asc</code></p><p><strong>输出参数 ：</strong></p><p><strong>a.resultType</strong></p><p>1.简单类型（8个基本+String）</p><p>2.输出参数为实体对象类型</p><p>3.输出参数为实体对象类型的集合 ：虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=”Student”）</p><p>4.输出参数类型为HashMap</p><p>如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个，<br>        再resultType都写成org.lanqiao.entity.Student<br>        即 resultType=”org.lanqiao.entity.Student”</p><p><strong>例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryAllstudentByName1&quot; parameterType=&quot;org.com.entity.Student&quot; resultType=&quot;org.com.entity.Student&quot;  &gt;</span><br><span class="line">select * from student where name=#&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><strong>b.resultMap:</strong> 实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;student&quot; id=&quot;queryStudentByIdMap&quot;&gt;</span><br><span class="line">&lt;!-- 指定类中的属性 和 表中的字段 对应关系 --&gt;</span><br><span class="line">&lt;id property=&quot;stuNo&quot;  column=&quot;id&quot; /&gt;</span><br><span class="line">&lt;result property=&quot;stuName&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><h4 id="a如果使用的-事务方式为-jdbc-则需要-手工commit提交，即session-commit"><a href="#a如果使用的-事务方式为-jdbc-则需要-手工commit提交，即session-commit" class="headerlink" title="a如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit();"></a>a如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit();</h4><h4 id="b所有的标签-select-update等-，都必须有sql语句，但是sql参数值可选"><a href="#b所有的标签-select-update等-，都必须有sql语句，但是sql参数值可选" class="headerlink" title="b所有的标签 select update等 ，都必须有sql语句，但是sql参数值可选"></a>b所有的标签 select update等 ，都必须有sql语句，但是sql参数值可选</h4><p> select* from student  where stuno = #{xx}<br>sql有参数：session.insert(statement, 参数值 );</p><p>sql没参数：session.insert(statement);</p><h1 id="二、mapper动态代理方式的crud-（MyBatis接口开发）"><a href="#二、mapper动态代理方式的crud-（MyBatis接口开发）" class="headerlink" title="二、mapper动态代理方式的crud （MyBatis接口开发）:"></a>二、mapper动态代理方式的crud （MyBatis接口开发）:</h1><p><strong>原则：约定优于配置</strong></p><p><strong>硬编码方式</strong><br>    abc.java<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = new Configuration();</span><br><span class="line">con.setName(&quot;myProject&quot;) ;</span><br><span class="line">   ```  </span><br><span class="line"></span><br><span class="line">**配置方式：**</span><br><span class="line">abc.xml   </span><br><span class="line">```&lt;name&gt;myProject&lt;/name&gt;</span><br></pre></td></tr></table></figure></p><p>约定：默认值就是myProject</p><p><strong>具体实现的步骤：</strong></p><h3 id="1-基础环境：mybatis-jar-ojdbc-jar、conf-xml、mapper-xml"><a href="#1-基础环境：mybatis-jar-ojdbc-jar、conf-xml、mapper-xml" class="headerlink" title="1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml"></a>1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml</h3><h3 id="2-（不同之处）"><a href="#2-（不同之处）" class="headerlink" title="2.（不同之处）"></a>2.（不同之处）</h3><pre><code>约定的目标： 省略掉statement,即根据约定 直接可以定位出SQL语句</code></pre><h4 id="a-接口，接口中的方法必须遵循以下约定："><a href="#a-接口，接口中的方法必须遵循以下约定：" class="headerlink" title="a.接口，接口中的方法必须遵循以下约定："></a>a.接口，接口中的方法必须遵循以下约定：</h4><h5 id="1-方法名和mapper-xml文件中标签的id值相同"><a href="#1-方法名和mapper-xml文件中标签的id值相同" class="headerlink" title="1.方法名和mapper.xml文件中标签的id值相同"></a>1.方法名和mapper.xml文件中标签的id值相同</h5><h5 id="2-方法的-输入参数-和mapper-xml文件中标签的-parameterType类型一致-如果mapper-xml的标签中没有-parameterType，则说明方法没有输入参数"><a href="#2-方法的-输入参数-和mapper-xml文件中标签的-parameterType类型一致-如果mapper-xml的标签中没有-parameterType，则说明方法没有输入参数" class="headerlink" title="2.方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数)"></a>2.方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数)</h5><h5 id="3-方法的返回值-和mapper-xml文件中标签的-resultType类型一致-（无论查询结果是一个-还是多个（student、List），在mapper-xml标签中的resultType中只写-一个（Student）；如果没有resultType，则说明方法的返回值为void）"><a href="#3-方法的返回值-和mapper-xml文件中标签的-resultType类型一致-（无论查询结果是一个-还是多个（student、List），在mapper-xml标签中的resultType中只写-一个（Student）；如果没有resultType，则说明方法的返回值为void）" class="headerlink" title="3.方法的返回值  和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void）"></a>3.方法的返回值  和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List<student>），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void）</student></h5><p>除了以上约定，要实现 接口中的方法  和  Mapper.xml中SQL标签一一对应，还需要以下1点：<br>    namespace的值 ，就是  接口的全类名（ 接口 - mapper.xml 一一对应）</p><p><strong>匹配的过程：（约定的过程）</strong><br>1.根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名）<br>2.根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值）</p><p>以上2点可以保证： 当我们调用接口中的方法时，<br>程序能自动定位到 某一个Mapper.xml文件中的sqL标签</p><p><strong>习惯：</strong>SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径）</p><p>以上，可以通过接口的方法-&gt;SQL语句</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentMapper studentMapper = session.getMapper(StudentMapper.class) ;</span><br><span class="line">studentMapper.方法();</span><br></pre></td></tr></table></figure><p>通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。</p><h1 id="关联查询："><a href="#关联查询：" class="headerlink" title="关联查询："></a>关联查询：</h1><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一:"></a>一对一:</h3><p><strong>a.业务扩展类</strong><br>        核心：用resultType指定类的属性 包含 多表查询的所有字段</p><p><strong>b.resultMap</strong><br>    1.通过 属性成员 将2个类建立起联系</p><pre><code>2.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;student&quot; id=&quot;student_card_map&quot;&gt;</span><br><span class="line">&lt;!-- 学生的信息 --&gt;</span><br><span class="line">&lt;id  property=&quot;stuNo&quot; column=&quot;stuNo&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;stuName&quot; column=&quot;stuName&quot; /&gt;</span><br><span class="line">&lt;result property=&quot;stuAge&quot; column=&quot;stuAge&quot; /&gt;</span><br><span class="line">&lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的--&gt;</span><br><span class="line">&lt;association property=&quot;card&quot; javaType=&quot;StudentCard&quot; &gt;</span><br><span class="line">&lt;id property=&quot;cardId&quot; column=&quot;cardId&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;cardInfo&quot; column=&quot;cardInfo&quot;/&gt;</span><br><span class="line">&lt;/association&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>一对一：association<br>一对多：collection</p><h3 id="一对多："><a href="#一对多：" class="headerlink" title="一对多："></a>一对多：</h3><p>表：student studentclass  (关联：classid)<br>类：student studentClass  (关联：List<student> students )</student></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select  c.*,s.* from student s</span><br><span class="line">inner join studentclass c </span><br><span class="line">on c.classid = s.classid</span><br><span class="line">where c.classid = 1;</span><br></pre></td></tr></table></figure><h3 id="多对一-多对多"><a href="#多对一-多对多" class="headerlink" title="多对一 多对多"></a>多对一 多对多</h3><p>MyBatis:多对一，多对多的本质就是  一对多的变化</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埼玉老师来啦</title>
      <link href="/2019/08/17/%E5%9F%BC%E7%8E%89%E8%80%81%E5%B8%88%E6%9D%A5%E5%95%A6/"/>
      <url>/2019/08/17/%E5%9F%BC%E7%8E%89%E8%80%81%E5%B8%88%E6%9D%A5%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="埼玉老师天下无敌"><a href="#埼玉老师天下无敌" class="headerlink" title="埼玉老师天下无敌"></a>埼玉老师天下无敌</h1><a id="more"></a><p><img src="1.jpg" alt="埼玉老师"></p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一拳超人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建遇到的小问题</title>
      <link href="/2019/08/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/08/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="小问题总结"><a href="#小问题总结" class="headerlink" title="小问题总结"></a>小问题总结</h2><h3 id="问题一：npm安装速度过慢"><a href="#问题一：npm安装速度过慢" class="headerlink" title="问题一：npm安装速度过慢"></a>问题一：npm安装速度过慢</h3><h3 id="解决方案：使用淘宝镜像站，命令如下："><a href="#解决方案：使用淘宝镜像站，命令如下：" class="headerlink" title="解决方案：使用淘宝镜像站，命令如下："></a>解决方案：使用淘宝镜像站，命令如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>过程可能会很慢，要是还不行就只能科学上网了 ，安装完之后就用cnpm代替npm命令就行啦</p><a id="more"></a><h3 id="问题二：hexo-d-命令无效"><a href="#问题二：hexo-d-命令无效" class="headerlink" title="问题二：hexo d 命令无效"></a>问题二：hexo d 命令无效</h3><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>注意repo：冒号后面要加上空格，类似其他的配置也要记得加空格！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxx</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
